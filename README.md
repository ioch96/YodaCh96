<h2>Hi, I'm Ioannis Christodoulakis!</h2>
<img align='right' src="https://media1.giphy.com/media/Wn74RUT0vjnoU98Hnt/200.gif" width="230">
<p><em>Hardware Engineer and Application Developer at <a href="https://www.zg.ch/behoerden/volkswirtschaftsdirektion/hfie">HFIE</a>
</em></p>

### A little more about me...

I'm a passionate self-taught software engineer from Greece. My passion for software lies with dreaming up ideas and making them come true with elegant interfaces. I take great care in the experience, architecture, and code quality of the things I build.

I am also an open-source enthusiast and maintainer. I learned a lot from the open-source community and I love how collaboration and knowledge sharing happened through open-source. I like to explore new technologies and develop software solutions. I am always on the lookout for new projects to work on and new people to collaborate with.

### Projects

- [Sudoku (Python)](https://github.com/YodaCh96/sudoku)
- [NIM (C)](https://github.com/YodaCh96/nim-game)
- [Dice rolling simulator (Python)](https://github.com/YodaCh96/dice-rolling-simulator)
- [Mathgraphs (Matlab)](https://github.com/YodaCh96/mathgraphs)
- [Reaktionsspiel (Arduino)](https://github.com/YodaCh96/reaktionsspiel)
- [Snake (Arduino)](https://github.com/YodaCh96/snake-game)
- [Delete Viber Files](https://github.com/YodaCh96/Del-Viber)
- [Alien Invasion](https://github.com/YodaCh96/Alien-Invasion)
- [CFS](https://github.com/Effie375/CFS)
- [TkGrades](https://github.com/Effie375/TkGrades)

### Tutorials

- [Learn Python 3 Codecademy](https://github.com/YodaCh96/Codecademy/blob/main/Learn_Python_3/README.md)
- [Python tutorial w3schools](https://www.w3schools.com/python/default.asp)
- [Python Crash Course](https://www.amazon.de/Python-Crash-Course-Hands-Project-Based/dp/1593276036)
- [HTML tutorial w3schools](https://www.w3schools.com/html/default.asp)
- [CSS tutorial w3schools](https://www.w3schools.com/css/default.asp)

### Certificates

- [Learn the Command Line](https://drive.google.com/file/d/1HfAKQo3v_OFbQfhz9RDSyskBhxIZV6U2/view?usp=sharing)

### ðŸ›  &nbsp;Tech Stack

![Python](https://img.shields.io/badge/-Python-05122A?style=flat&logo=python)&nbsp;
![C](https://img.shields.io/badge/-C-05122A?style=flat&logo=C&logoColor=A8B9CC)&nbsp;
![C++](https://img.shields.io/badge/-C++-05122A?style=flat&logo=C%2B%2B&logoColor=00599C)&nbsp;
![HTML](https://img.shields.io/badge/-HTML-05122A?style=flat&logo=HTML5)&nbsp;
![CSS](https://img.shields.io/badge/-CSS-05122A?style=flat&logo=CSS3&logoColor=1572B6)&nbsp;
![Git](https://img.shields.io/badge/-Git-05122A?style=flat&logo=git)&nbsp;
![GitHub](https://img.shields.io/badge/-GitHub-05122A?style=flat&logo=github)&nbsp;
![Markdown](https://img.shields.io/badge/-Markdown-05122A?style=flat&logo=markdown)
![Visual Studio Code](https://img.shields.io/badge/-Visual%20Studio%20Code-05122A?style=flat&logo=visual-studio-code&logoColor=007ACC)&nbsp;

---

[![](https://raw.githubusercontent.com/YodaCh96/YodaCh96/master/profile-summary-card-output/nord_dark/0-profile-details.svg)](https://github.com/vn7n24fzkq/github-profile-summary-cards)
[![](https://raw.githubusercontent.com/YodaCh96/YodaCh96/master/profile-summary-card-output/nord_dark/1-repos-per-language.svg)](https://github.com/vn7n24fzkq/github-profile-summary-cards) [![](https://raw.githubusercontent.com/YodaCh96/YodaCh96/master/profile-summary-card-output/nord_dark/2-most-commit-language.svg)](https://github.com/vn7n24fzkq/github-profile-summary-cards)
[![](https://raw.githubusercontent.com/YodaCh96/YodaCh96/master/profile-summary-card-output/nord_dark/3-stats.svg)](https://github.com/vn7n24fzkq/github-profile-summary-cards) [![](https://raw.githubusercontent.com/YodaCh96/YodaCh96/master/profile-summary-card-output/nord_dark/4-productive-time.svg)](https://github.com/vn7n24fzkq/github-profile-summary-cards)

----

<!-- ### Hardware Engineer at GIBZ -->

<!-- #### Hardware and software engineering -->

<!-- ### Application Development at HFIE -->

<!-- ### Strukturierte Programmierung -->
<!-- #### Structured programming -->

<!-- #### Kompetenzen -->
<!-- ##### Skills -->

<!--
- Ein Problem analysieren und einen geeigneten Algorithmus zur LÃ¶sung mit den Grundelementen Zuweisung, Verzweigung und Schleife entwerfen und in Form einer Ablaufstruktur abbilden.
- Schnittstellen zwischen Modulen bestimmen und mit einer strukturierten Methode (Structured Charts, Data Dictionary, Modulspezifikation) dokumentieren.
- Die erforderlichen Datenstrukturen fÃ¼r Eingabe, Verarbeitung und Ausgabe bestimmen und ihre Datentypen festlegen.
- Datentypen und Datenstrukturen wie Structs und Arrays hinsichtlich SpeichergrÃ¶sse analysieren.
- Benutzerschnittstelle auf Konsolenbasis fÃ¼r die Eingabe und Ausgabe der Daten erstellen.
- Ein komplexeres Problem auf kleinere Teilprobleme aufteilen und in Unterprogrammen (Funktionen) umsetzen.
- Den Quellcode verstÃ¤ndlich darstellen (Variablennamen, Struktur, EinrÃ¼ckungen, Kommentare), um die Nachvollziehbarkeit des Programms sicher zu stellen.
- Einen Debugger einsetzen um die ProgrammausfÃ¼hrung zu Ã¼berwachen und Fehler zu erkennen.
- Programmcode auf funktionale Korrektheit testen.
- Abnahmetests (Black-Box-Test) definieren, um die fehlerfreie Verarbeitung des Programms sicher zu stellen.
-->
<!--
- Analyse a problem and design a suitable algorithm to solve it using the basic elements of assignment, branching and looping and map it in the form of a flow structure.
- Determine interfaces between modules and document them with a structured method (structured charts, data dictionary, module specification).
- Determine the required data structures for input, processing and output and define their data types.
- Analyse data types and data structures such as structs and arrays with regard to memory size.
- Create a console-based user interface for data input and output.
- Divide a more complex problem into smaller subproblems and implement them in subroutines (functions).
- Present the source code in a comprehensible way (variable names, structure, indentations, comments) to ensure the comprehensibility of the programme.
- Use a debugger to monitor programme execution and detect errors.
- Test programme code for functional correctness.
- Define acceptance tests (black box test) to ensure error-free processing of the programme.
-->
<!-- #### Kenntnisse -->
<!-- ##### Knowledge -->

<!--
- Kennt die wichtigsten Kontrollstrukturen der strukturierten Programmierung (Sequenz, Selektion, Iteration) und kann an Beispielen erlÃ¤utern, welche Sachverhalte im Ablauf eines Algorithmus diesen Kontrollstrukturen entsprechen.
- Kennt eine Notation fÃ¼r die Abbildung einer Programmlogik (z.B. Nassi Shneidermann) und kann aufzeigen, wie darin die wichtigsten Kontrollstrukturen und der Ablauf eines Programms abgebildet werden.
- Kennt dargestellte Sachverhalte in einem Struktogramm und weitere Vorgaben, die bei der Bildung von Modulen zu berÃ¼cksichtigen sind und kann aufzeigen, wie damit die Ãœbersichtlichkeit eines Programms verbessert und die Effizienz der Programmierung gesteigert werden kann.
- Kennt Techniken zur Darstellung von Beziehungen zwischen Modulen und kann erlÃ¤utern, wie damit die Reihenfolge der Aufrufe und die Ãœbergabeparameter dargestellt werden kÃ¶nnen.
- Kennt die Informationen, welche ein Data Dictionary enthÃ¤lt und kann erlÃ¤utern, zu welchem Zweck diese Informationen bei der Erstellung eines Programms genutzt werden kÃ¶nnen.
- Kennt den Unterschied zwischen Wertevariablen und Referenzvariablen / Zeigervariablen.
- Kennt die wichtigsten Datentypen (char, int, float, double, string), ihren Speicherbedarf und Wertebereich.
- Kennt die Regeln der impliziten und expliziten Datentypenkonvertierung und kann aufzeigen, welche Auswirkungen diese hinsichtlich Genauigkeit und Aussage haben.
- Kennt Eigenschaften von einzelnen abstrakten Datentypen.
- Kennt die Eigenschaften und Vorteile der Verwendung von Arrays.
- Kennt den grundlegenden Aufbau eines Programms (Positionierung von Deklaration, Definition und Verarbeitung usw.) und kann diesen Aufbau an einem Programm beispielhaft erlÃ¤utern.
- Kennt den Sinn und Zweck von Variablen und Konstanten, sowie deren Unterschied und GÃ¼ltigkeitsbereich.
- Kennt  die  grundlegenden  Befehle  einer  Programmiersprache  zur  Umsetzung  von  Anweisungen, Kontrollstrukturen, Bedingungen und Operatoren.
- Kennt  die  grundlegenden  Befehle  einer  Programmiersprache  zur  Umsetzung  von  Anweisungen, Kontrollstrukturen, Bedingungen und Operatoren.
- Kennt die wichtigsten Regeln, die bei der Dateneingabe und Datenausgabe auf dem Bildschirm einzuhalten sind (Bezeichnung der Informationen, Format fÃ¼r Dateneingabe usw.) und kann erlÃ¤utern, welche Probleme sich ergeben, wenn diese Regeln nicht eingehalten werden.
- Kennt eine Methode zur Abgrenzung und Zerlegung einer Aufgabenstellung in Funktionen (Top Down) und kann dies auch im Programmcode implementieren.
- Kennt den Aufbau von iterativen und rekursiven Algorithmen.
- Kennt Vor- und Nachteile sowie geeignete Einsatzgebiete des iterativen und des rekursiven Ansatzes.
- Kennt Codekonventionen (Programmstandards) und kann an Beispielen aufzeigen. Welchen Beitrag die Einhaltung solcher Konventionen fÃ¼r die Lesbarkeit und Wartbarkeit der Programme leisten.
- Kennt die wichtigsten Regeln fÃ¼r einen verstÃ¤ndlichen Quellcode (sprechende Variablenbezeichnungen, geeignete Kommentare) und kann erlÃ¤utern, welchen Beitrag diese Angaben zur Lesbarkeit von Programmen leisten.
- Kennt den Zweck, die Funktionen und die Bedienung eines Debugger.
- Kennt die MÃ¶glichkeiten einer Entwicklungsumgebung, sowie den Umgang mit Fehler und Warnmeldungen.
- Kennt den Nutzen von Breakpoints und der Ãœberwachung von Variablen zur Kontrolle von ProgrammablÃ¤ufen und Bedingungen.
- Kennt die grundlegenden Schritte, die bei einem Test durchlaufen werden mÃ¼ssen und kann aufzeigen, welchen Beitrag diese zu einem qualitativ guten Ergebnis leisten.
- Kennt Kriterien fÃ¼r die Definition eines Testfalls und die gezielte Auswahl der Testdaten.
- Kennt Prinzipien, die bei der Definition von Testdaten und TestfÃ¤llen berÃ¼cksichtigt werden mÃ¼ssen und kann aufzeigen, wie damit eine vollstÃ¤ndige und korrekte Verarbeitung der Informationen in einem Programm (White Box Test, Black Box Test) Ã¼berprÃ¼ft werden kann.
- Kennt die Bedeutung von Grenzwerten beim Testen und kann an Beispielen aufzeigen, wie damit die Korrektheit von Bedingungen in Programmen nachgewiesen werden kann.
- Kennt den Aufbau eines Testprotokolls und kann an Beispielen aufzeigen, welche Ziele mit dem Testprotokoll verfolgt werden (Was, wann, von wem, wie intensiv und mit welchem Ergebnis getestet).
-->
<!--
- Knows the most important control structures of structured programming (sequence, selection, iteration) and can use examples to explain which facts in the flow of an algorithm correspond to these control structures.
- Knows a notation for the representation of a programme logic (e.g. Nassi Shneidermann) and can show how the most important control structures and the sequence of a programme are represented in it.
- Knows represented facts in a structure diagram and other specifications to be taken into account when forming modules and can show how this can improve the clarity of a programme and increase the efficiency of programming.
- Knows techniques for representing relationships between modules and can explain how this can be used to represent the order of calls and the passing parameters.
- Knows the information contained in a data dictionary and can explain the purpose for which this information can be used when creating a programme.
- Knows the difference between value variables and reference variables / pointer variables.
- Knows the most important data types (char, int, float, double, string), their memory requirements and value range.
- Knows the rules of implicit and explicit data type conversion and can show what effects these have in terms of accuracy and statement.
- Knows properties of individual abstract data types.
- Knows the properties and advantages of using arrays.
- Knows the basic structure of a programme (positioning of declaration, definition and processing, etc.) and can explain this structure using a programme as an example.
- Knows the meaning and purpose of variables and constants, as well as their difference and range of validity.
- Knows the basic commands of a programming language for implementing instructions, control structures, conditions and operators.
- Knows the basic commands of a programming language for implementing instructions, control structures, conditions and operators.
- Knows the main rules to be followed for data input and data output on the screen (designation of information, format for data input, etc.) and can explain what problems arise if these rules are not followed.
- Knows a method for delimiting and breaking down a task into functions (top down) and can also implement this in the programme code.
- Knows the structure of iterative and recursive algorithms.
- Knows the advantages and disadvantages as well as suitable areas of application of the iterative and recursive approach.
- Knows code conventions (programme standards) and can demonstrate them with examples. What contribution adherence to such conventions makes to the readability and maintainability of programmes.
- Knows the most important rules for comprehensible source code (speaking variable names, suitable comments) and can explain what contribution these details make to the readability of programmes.
- Knows the purpose, functions and operation of a debugger.
- Knows the possibilities of a development environment, as well as how to deal with errors and warning messages.
- Knows the usefulness of breakpoints and monitoring variables to control programme sequences and conditions.
- Knows the basic steps to go through in a test and can demonstrate how these contribute to a good quality result.
- Knows criteria for the definition of a test case and the specific selection of test data.
- Knows principles that must be taken into account when defining test data and test cases and can show how this can be used to check complete and correct processing of the information in a programme (white box test, black box test).
- Knows the importance of limit values in testing and can show by means of examples how the correctness of conditions in programmes can be verified.
- Knows the structure of a test protocol and can use examples to show which goals are pursued with the test protocol (what is tested, when, by whom, how intensively and with what result).
-->

<!-- ### Algorithmen & Datenstrukturen -->
<!-- #### Algorithms & Data Structures -->

<!-- #### Kompetenzen -->
<!-- ##### Skills -->

<!--
- Verschiedene Datenstrukturen kennen und anwenden.
- Evaluation geeigneter Datenstrukturen.
- Verschiedene Such- und Sortieralgorithmen anwenden.
- Zeit- und SpeicherkomplexitÃ¤t hinsichtlich bekannter Algorithmen verstehen.
- Endliche Automaten verstehen und anwenden.
-->
<!--
- Know and apply different data structures.
- Evaluate suitable data structures.
- Apply different search and sorting algorithms.
- Understand time and memory complexity with respect to known algorithms.
- Understand and apply finite automata.
-->
<!-- #### Kenntnisse -->
<!-- ##### Knowledge -->

<!--
- Funktionsweise relevanter Datenstrukturen (z.B. Array, Liste, Stack, Queue, Baum, Tabellen) erklÃ¤ren.
- GÃ¤ngige Datenstrukturen selbstÃ¤ndig implementieren.
- Datenstrukturen hinsichtlich FunktionalitÃ¤t, Effizienz und LeistungsfÃ¤higkeit beurteilen.
- Geeignete Datenstrukturen zur LÃ¶sung eines gegebenen Problems auswÃ¤hlen.
- Konzepte zum Suchen nach Buchstabenfolgen kennen und implementieren (z.B. RegulÃ¤re AusdrÃ¼cke, unscharfe Suche, String-Matching Algorithmen).
- Klassische Algorithmen zur Suche in Listen, BÃ¤umen und Graphen verstehen und selbstÃ¤ndig implementieren.
- Klassische Sortieralgorithmen (z.B. Quicksort, Bubblesort, Mergesort, ...) verstehen und selbstÃ¤ndig implementieren.
- Konzepte der Zeit- und SpeicherkomplexitÃ¤t verstehen.
- Bekannte Such- und Sortieralgorithmen hinsichtlich ihrer Zeit- und SpeicherkomplexitÃ¤t beurteilen.
- Geeignete Such- und Sortieralgorithmen fÃ¼r eine gegebene Problemstellung auswÃ¤hlen und implementieren.
- Verschiedene Klassen endlicher Automaten kennen (z.B. Akzeptoren, Transduktoren).
- Anwendungsgebiete endlicher Automaten in der Softwareentwicklung kennen.
- Einfache endliche Automaten implementieren.
-->
<!--
- Explain how relevant data structures (e.g. array, list, stack, queue, tree, tables) work.
- Implement common data structures independently.
- Evaluate data structures in terms of functionality, efficiency and performance.
- Select suitable data structures to solve a given problem.
- Know and implement concepts for searching for letter sequences (e.g. regular expressions, fuzzy search, string matching algorithms).
- Understand and independently implement classical algorithms for searching lists, trees and graphs.
- Understand classical sorting algorithms (e.g. quicksort, bubblesort, mergesort, ...) and implement them independently.
- Understand concepts of time and memory complexity.
- Evaluate known search and sorting algorithms with regard to their time and memory complexity.
- Select and implement suitable search and sorting algorithms for a given problem.
- Know different classes of finite automata (e.g. acceptors, transductors).
- Know areas of application of finite automata in software development.
- Implement simple finite automata.
-->

<!-- ### Datenbanktechnik -->
<!-- #### Database technology -->

<!-- #### Kompetenzen -->
<!-- ##### Skills -->

<!--
- Daten bzw. Datenbestand nach den fÃ¼r die Verarbeitung resp. Auswertung wichtigen Merkmalen hinsichtlich Struktur (Text, DatenblÃ¤tter, Datenbank usw.) charakterisieren.
- Unstrukturierte Daten in eine strukturierte, bearbeitbare Form bringen, um Auswertungen zu ermÃ¶glichen.
- FÃ¼r Daten und ZusammenhÃ¤nge eine geeignete visuell erfassbare Form wÃ¤hlen und diese in der gewÃ¤hlten Form darstellen.
- Konzeptionelles Datenbankschema interpretieren anhand von EntitÃ¤ten, Attributen und Beziehungen.
- Konzeptionelles Datenmodell erstellen und fehlende Informationen ermitteln bzw. Redundanzen klÃ¤ren.
- Ein gegebenes ERM in ein internes Datenbankschema Ã¼berfÃ¼hren (Definieren von Tabellen/Relationen, SchlÃ¼sseln, Indizes, Konsistenzbedingungen).
- Logisches Datenbankschema ermitteln, normalisieren und als Diagramm darstellen.
- Logisches Datenbankschema mit einer Datenbanksoftware implementieren.
- Mit einer Datenbanksoftware Benutzerschnittstellen zur Erfassung, VerÃ¤nderung und Auswertung von Daten unter BerÃ¼cksichtigung von Datenschutz und Datensicherheit in einer Datenbank erstellen.
- Implementiert ein vorgegebenes, logisches Datenbankschema in ein relationales Datenbank Management System (RDBMS) mit einer Datenbanksoftware oder mit Structured Query Language-Befehlen (SQL).
- Mit SQL-Befehlen Transaktionen zur Bearbeitung und Auswertung der Datenbank ausfÃ¼hren.
- Selektiert und manipuliert die DatenbestÃ¤nde eines RDBMS mit SQL-Befehlen.
-->
<!--
- Characterise data or data stock according to the features important for processing or evaluation with regard to structure (text, data sheets, database, etc.).
- Put unstructured data into a structured, processable form to enable evaluations.
- Select a suitable visually recordable form for data and correlations and present them in the chosen form.
- Interpret conceptual database schema using entities, attributes and relationships.
- Create conceptual data model and identify missing information or clarify redundancies.
- Convert a given ERM into an internal database schema (define tables/relations, keys, indices, consistency conditions).
- Determine logical database schema, normalise it and represent it as a diagram.
- Implement logical database schema with database software.
- Using database software, create user interfaces for entering, changing and evaluating data, taking into account data protection and data security in a database.
- Implement a given logical database schema in a relational database management system (RDBMS) using database software or Structured Query Language (SQL) commands.
- Use SQL commands to execute transactions to manipulate and evaluate the database.
- Selects and manipulates the datasets of an RDBMS with SQL commands.
-->
<!-- #### Kenntnisse -->
<!-- ##### Knowledge -->

<!--
- Kennt die verschiedenen Formen von Daten (numerische - Messdaten/ Klassifikationen; verbale - Texte in schriftlicher oder gesprochener Form; nonverbale - Musik, Filme, Videos) die auf einem DatentrÃ¤ger gespeichert werden kÃ¶nnen und kann aufzeigen, wie sich diese Daten hinsichtlich der Auswertbarkeit mit einem Computersystem verhalten.
- Kennt die Strukturmerkmale verschiedener Informationsquellen (Textdokument, DatenblÃ¤tter, Datenbanken) und kann erlÃ¤utern, welche Konsequenzen sich daraus fÃ¼r die elektronische Auswertung dieser Datenquellen ergeben.
- Kennt die Beziehungen zwischen Datenstrukturen (Assoziationen, KardinalitÃ¤ten) und kann an Beispielen aus dem Alltag aufzeigen, welche Sachverhalte sich damit in einem Datenbestand abbilden lassen.
- Kann die Skalentypen nominal ("alt" - "jung", "ungenÃ¼gend" - "genÃ¼gend" - "gut"), ordinal (RÃ¤nge, Noten etc.) und metrisch (Alter, GrÃ¶sse etc.) unterscheiden und die Konsequenzen aufzeigen, die sich daraus fÃ¼r die AuswertungsmÃ¶glichkeiten ableiten lassen.
- Kennt die verbreiteten Datentypen (Zahl, Zeit, Datum, Text etc.) und kann deren Grenzen hinsichtlich der Auswertbarkeit von Daten aufzeigen.
- Kennt die einfachsten statistischen KenngrÃ¶ssen (Mittelwert, Minimum, Maximum) und kann aufzeigen, welche Voraussetzungen (Skalentypen, Anzahl Beobachtungen, QualitÃ¤t der Daten etc.) erfÃ¼llt sein mÃ¼ssen, damit diese eine zuverlÃ¤ssige Aussage machen.
- Kennt die einfachsten Diagrammtypen fÃ¼r die Darstellung von Daten und kann erlÃ¤utern, bei welchen Skalentypen der Daten (metrisch-, nominal-, ordinal-skalierte) sich diese eignen.
- Kennt die Begriffe EntitÃ¤t, Attribut und Beziehung in einem konzeptionellen Datenbankschema und deren Darstellung.
- Kennt die unterschiedlichen KardinalitÃ¤ten und deren Aussage bezÃ¼glich der Beziehungen.
- Kennt die methodische Vorgehensweise bei der Entwicklung eines konzeptionellen Datenmodells und kann fÃ¼r die einzelnen Schritte erlÃ¤utern, wie dabei vorgegangen wird.
- Kennt die Regeln, welche beim Spezialisieren bzw. Generalisieren von Objekten in EntitÃ¤tsmengen und Beziehungen zu beachten sind.
- Kennt die Elemente der Notation eines ERM und kann anhand von Beispielen erlÃ¤utern, welche Art von Datenelementen und -beziehungen damit abgebildet werden.
- Kennt Aufbau und Struktur eines Datenbankschemas und kann aufzeigen, welche Aussagen die Elemente hinsichtlich der physischen Implementierung der Datenbank machen.
- Kennt das Vorgehen eines Datenbankentwurfs (Tabellen identifizieren, Attribute definieren, Beziehungen klÃ¤ren) und kann diesen Entwurf als ER-Diagramm darstellen.
- Kennt die Elemente eines Datenbankprogramms zur Umsetzung eines Datenmodells in ein physisches Datenbankschema.
- Kennt GUI-Komponenten und Formularfelder fÃ¼r die Definition von Benutzerschnittstellen zur Erfassung, VerÃ¤nderung sowie Auswertung von Daten.
- Kennt die wichtigsten Regeln, die bei der ergonomischen Gestaltung einer BenutzeroberflÃ¤che fÃ¼r eine Datenbank hinsichtlich Abfolge und Bezeichnung der Informationen einzuhalten sind.
- Kennt die wichtigsten Abfragen zur Manipulation, Selektion und Auswertung von DatenbestÃ¤nden.
-  Kennt die eigene Entwicklungsumgebung und Werkzeuge (Tools), um SQL-Skripte zu erstellen und mÃ¶gliche Codierungsfehler zu beheben.
-  Kennt den wesentlichen Aufbau (Syntax) und die Bedeutung (Semantik) von SQL-Befehlen.
-  Kennt die wesentlichen Bestandteile eines relationalen Datenbank Management Systems (RDBMS).
-  Kennt die wichtigsten SQL-Befehle oder eine Datenbanksoftware, um eine Datenbank in einem RDBMS gemÃ¤ss Vorgaben einzurichten.
-  Kennt die Befehle einer Datenmanipulations- und Abfragesprache (DML, SQL) zur Manipulation, Selektion und Auswertung von DatenbestÃ¤nden.
-  Kennt die wichtigsten SQL-Befehle und deren Aufbau zur Selektion und Auswertung von DatenbestÃ¤nden (Ã¼ber eine oder mehrere Tabellen).
-  Kennt die wichtigsten SQL-Befehle und deren Aufbau zur Manipulation von DatenbestÃ¤nden.
-  Kennt hÃ¤ufige Fehlerquellen bei der Programmierung mit SQL und Vorgehensweisen zur selbstÃ¤ndigen Fehlerbehebung.
-->
<!--
- Knows the different forms of data (numerical - measurement data/ classifications; verbal - texts in written or spoken form; non-verbal - music, films, videos) that can be stored on a data carrier and can show how these data behave in terms of evaluability with a computer system.
- Knows the structural features of different information sources (text document, data sheets, databases) and can explain which consequences result from this for the electronic evaluation of these data sources.
- Knows the relationships between data structures (associations, cardinalities) and can use examples from everyday life to show which facts can thus be represented in a data set.
- Can distinguish between nominal ("old" - "young", "insufficient" - "sufficient" - "good"), ordinal (ranks, grades, etc.) and metric (age, height, etc.) scale types and show the consequences that can be derived from this for the evaluation possibilities.
- Knows the common types of data (number, time, date, text, etc.) and can point out their limits with regard to the evaluability of data.
- Knows the simplest statistical parameters (mean, minimum, maximum) and can show which conditions (scale types, number of observations, quality of the data, etc.) must be fulfilled in order to make a reliable statement.
- Knows the simplest chart types for the representation of data and can explain for which scale types of data (metric-, nominal-, ordinal-scaled) they are suitable.
- Knows the concepts of entity, attribute and relationship in a conceptual database schema and how they are represented.
- Knows the different cardinalities and what they mean in terms of relationships.
- Knows the methodological procedure for developing a conceptual data model and can explain how to proceed for the individual steps.
- Knows the rules to be observed when specialising or generalising objects in entity sets and relationships.
- Knows the elements of the notation of an ERM and can explain by means of examples what kind of data elements and relationships are represented with it.
- Knows the structure of a database schema and can show what statements the elements make with regard to the physical implementation of the database.
- Knows the procedure of a database design (identify tables, define attributes, clarify relationships) and can present this design as an ER diagram.
- Knows the elements of a database programme to convert a data model into a physical database schema.
- Knows GUI components and form fields for defining user interfaces for entering, changing as well as evaluating data.
- Knows the most important rules to be observed in the ergonomic design of a user interface for a database with regard to the sequence and designation of information.
- Knows the most important queries for manipulating, selecting and evaluating databases.
- Knows the own development environment and tools (tools) to create SQL scripts and to correct possible coding errors.
- Knows the essential structure (syntax) and the meaning (semantics) of SQL commands.
- Knows the essential components of a relational database management system (RDBMS).
- Knows the most important SQL commands or database software to set up a database in an RDBMS according to specifications.
- Knows the commands of a data manipulation and query language (DML, SQL) for manipulating, selecting and evaluating data sets.
- Knows the most important SQL commands and their structure for selecting and evaluating datasets (via one or more tables).
- Knows the most important SQL commands and their structure for manipulating data sets.
- Knows common sources of errors when programming with SQL and procedures for independent error correction.
-->

<!-- ### Objektorientiert implementieren -->
<!-- #### Implement object-oriented -->

<!-- #### Kompetenzen -->
<!-- ##### Skills -->

<!--
- Die Notation dynamischer und statischer Strukturen einer Anwendung mittels Unified Modeling Language (UML) nachvollziehen.
- Klassenbasiertes Design implementieren.
- Eine Benutzerschnittstelle entwerfen und implementieren.
- Klassen der Anwendung systematisch, unter Verwendung der hierfÃ¼r vorgesehenen Infrastruktur, dokumentieren.
- Beim Programmieren vorgegebene Standards und Richtlinien einhalten, das Programm inline dokumentieren und dabei auf Wartbarkeit und Nachvollziehbarkeit achten.
- Programm auf Einhaltung der FunktionalitÃ¤t testen, Fehler erkennen und beheben.
- FÃ¼r funktionale Einheiten einer Anwendung TestfÃ¤lle implementieren, um die Anwendung automatisch zu prÃ¼fen (Unit Test).
-->
<!--
- Understand the notation of dynamic and static structures of an application using Unified Modelling Language (UML).
- Implement class-based design.
- Design and implement a user interface.
- Document classes of the application systematically, using the infrastructure provided for this purpose.
- Comply with standards and guidelines when programming, documenting the programme inline, taking care to ensure maintainability and traceability.
- Test the programme for compliance with functionality, detect and correct errors.
- Implement test cases for functional units of an application in order to automatically test the application (unit test).
-->
<!-- #### Kenntnisse -->
<!-- ##### Knowledge -->

<!--
- Kennt Abstraktionsmittel wie Beziehungen, Klassen, Objekte, Attribute und Methoden, mit denen die reale Welt im Design abgebildet wird.
- Versteht die Klasse als abstrakten Datentyp (ADT).
- Versteht das Zusammenspiel mehrerer Klassen in einer Anwendung.
- Kennt die Beziehungstypen wie Assoziation, Aggregation, Komposition zwischen Klassen.
- Kennt die Bedeutung von Super- und Sub-Klassen, die fÃ¼r die Implementation der Anwendung nÃ¶tig sind und das klassenbasierte Design vervollstÃ¤ndigen.
- Kann durch die Anwendung von Vererbung Redundanzen im Klassendesign eliminieren.
- BerÃ¼cksichtigt beim Erstellen von Vererbungshierarchien das Prinzip von Spezialisierung / Generalisierung inklusive abstrakter Klassen.
- Kennt Diagrammnotationen zur Darstellung von Schnittstellen.
- Kennt Diagrammnotationen zur Darstellung des Meldungsaustausches zwischen Objekten.
- Kann fÃ¼r ein Fallbeispiel die objektorientierte Analyse durchfÃ¼hren und die Ergebnisse unter Zuhilfenahme der Diagramme: Kontextdiagramm, Use Case Diagramm, Objektdiagramm, Klassendiagramm und  Sequenzdiagramm darstellen.
- Kennt eine objektorientierte Sprache, welche fÃ¼r die Umsetzung des klassenbasierten Designs geeignet ist.
- Kann das Prinzip des Information Hiding und der Kapselung beim Entwurf von Klassen anwenden.
- Versteht den Unterschied zwischen dem Programm zur Kompilationszeit (Klassen) und zur Laufzeit (sich referenzierende Objekte).
- Kennt Elemente einer objektorientierten Sprache fÃ¼r die Umsetzung der Vererbung im objektorientierten Design.
- Kennt Elemente einer objektorientierten Sprache fÃ¼r das Ãœberschreiben von Methoden im objektorientierten Design.
- Kann an einem Codebeispiel den Effekt von Polymorphie aufzeigen.
- Kennt Elemente einer objektorientierten Sprache fÃ¼r die Realisierung von Schnittstellen und abstrakten Klassen.
- Kann aufzeigen, wie durch die Nutzung von Schnittstellen der Code unabhÃ¤ngig erstellt und getestet werden kann.
- Kennt die wichtigsten Regeln fÃ¼r den Aufbau einer Benutzerschnittstelle.
- Kennt LÃ¶sungsansÃ¤tze fÃ¼r die Verarbeitung und Validierung von Benutzerinteraktionen.
- Kennt die MÃ¶glichkeiten der Dokumentationsinfrastruktur und weiss wie die Programmeinheiten gemÃ¤ss Vorgaben zu dokumentieren sind.
- Kennt die wichtigsten Regeln fÃ¼r einen verstÃ¤ndlichen Quellcode (sprechende Komponenten- und Variablenbezeichnungen, optische Strukturierung, sinnvolle Kommentare).
- Kennt die Elemente eines Testfalls (zu testende Funktion oder Verarbeitung, Eingabedaten, erwartete Ergebnisse).
- Kennt die Bedeutung des Testens fÃ¼r die Sicherung der ProgrammqualitÃ¤t.
- Kennt das Hilfsmittel des Mockings um AbhÃ¤ngigkeiten aus den TestfÃ¤llen zu eliminieren.
- Kennt Mittel zur Isolierung der Testdaten und TestfÃ¤lle, um die gegenseitige UnabhÃ¤ngigkeit der TestfÃ¤lle zu garantieren.
- Kennt Werkzeuge zur Implementation von isolierten TestfÃ¤llen.
- Kennt Vorgehen um fÃ¼r Programmteile TestfÃ¤lle mittels geeigneter Grenzwerte oder PfadprÃ¼fungen zu finden und festzulegen.
- Kennt die zur VerfÃ¼gung gestellten Mittel einer Testinfrastruktur um die TestfÃ¤lle zu implementieren.
- Kennt Mittel, die Abdeckung der Tests zu messen.
-->
<!--
- Knows abstraction tools such as relationships, classes, objects, attributes and methods used to represent the real world in design.
- Understands class as an abstract data type (ADT).
- Understands the interaction of multiple classes in an application.
- Knows the relationship types such as association, aggregation, composition between classes.
- Knows the importance of super and sub classes which are necessary for the implementation of the application and complete the class-based design.
- Can eliminate redundancy in class design through the use of inheritance.
- Considers the principle of specialisation / generalisation including abstract classes when creating inheritance hierarchies.
- Knows diagram notations to represent interfaces.
- Knows diagram notations to represent message exchanges between objects.
- Can carry out object-oriented analysis for a case study and present the results with the aid of diagrams: Context diagram, Use Case diagram, Object diagram, Class diagram and Sequence diagram.
- Knows an object-oriented language suitable for implementing class-based design.
- Can apply the principle of information hiding and encapsulation when designing classes.
- Understands the difference between the programme at compile time (classes) and at run time (referencing objects).
- Knows elements of an object-oriented language for implementing inheritance in object-oriented design.
- Knows elements of an object-oriented language for overriding methods in object-oriented design.
- Can demonstrate the effect of polymorphism in a code example.
- Knows elements of an object-oriented language for the realisation of interfaces and abstract classes.
- Can show how code can be created and tested independently through the use of interfaces.
- Knows the most important rules for building a user interface.
- Knows approaches for processing and validating user interactions.
- Knows the possibilities of the documentation infrastructure and how to document the programme units according to specifications.
- Knows the most important rules for an understandable source code (speaking component and variable names, visual structuring, meaningful comments).
- Knows the elements of a test case (function or processing to be tested, input data, expected results).
- Knows the importance of testing for ensuring programme quality.
- Knows the tool of mocking to eliminate dependencies from test cases.
- Knows means of isolating test data and test cases to guarantee mutual independence of test cases.
- Knows tools for implementing isolated test cases.
- Knows procedures to find and define test cases for programme parts by means of suitable limits or path checks.
- Knows the means provided by a test infrastructure to implement the test cases.
- Knows the means to measure the coverage of the tests.
-->

<!-- ### Prozesssimulation mit Matlab -->
<!-- #### Process simulation with Matlab -->

<!-- #### Kompetenzen -->
<!-- ##### Skills -->

<!--
- Arbeiten mit Matlab- OberflÃ¤che.
- Eingeben von Befehlen und Erzeugen von Variablen.
- Analyse und Visualisierung von Vektor- und Matrixdaten.
- Umgang mit verschiedenen Datentypen.
- Tabellarische Daten.
- Bedingte Datenauswahl und Datenorganisation.
- Datenanalyse.
- Automatisieren von AblÃ¤ufen mit Skripten und Funktionen.
- Programmieren von bedingten Anweisungen und Schleifen.
- Optimierungsprobleme lÃ¶sen.
- Zielfunktionen definieren.
- Nebenbedingungen festlegen.
- Ergebnisse analysieren und Laufzeit verbessern.
- Globale Optimierungsmethoden verwenden.
- Gestalten des Layouts mit dem App Designer.
- Erstellen von Callback-Funktionen fÃ¼r interaktive Komponenten.
- Erzeugen und aktualisieren grafischer Objekte.
- Erstellen von Anwendungskomponenten, die auf Benutzerverhalten reagieren.
- Erstellen von Apps mit mehreren Fenstern.
-->
<!--
- Working with Matlab interface.
- Entering commands and creating variables.
- Analysing and visualising vector and matrix data.
- Working with different types of data.
- Tabular data.
- Conditional data selection and data organisation.
- Data analysis.
- Automating procedures with scripts and functions.
- Programming conditional statements and loops.
- Solving optimisation problems.
- Defining objective functions.
- Set constraints.
- Analyse results and improve runtime.
- Use global optimisation methods.
- Designing the layout with the App Designer.
- Create callback functions for interactive components.
- Create and update graphical objects.
- Create application components that respond to user behaviour.
- Create apps with multiple windows.
-->
<!-- #### Kenntnisse -->
<!-- ##### Knowledge -->

<!--
- Kennt die wichtigen FunktionalitÃ¤ten und die zugehÃ¶rigen BenutzeroberflÃ¤chen.
- Kann Befehle eingeben und numerische Variablen und Textvariablen erstellen.
- Kann Grafiken beschriften.
- Kann Skripten erzeugen und ausfÃ¼hren.
- Kann mit Vektoren rechnen.
- Kann auf Werte in Variablen zugreifen und diese Ã¤ndern.
- Kann Matrizen erstellen, berechnen und manipulieren.
- Kann tabellarische Daten importieren und verarbeiten.
- Kann TeildatensÃ¤tze extrahieren und analysieren.
- Kann eine komplette Datenanalyse durchfÃ¼hren.
- Kann Verzweigungen und Schlaufen programmieren.
- Kann benutzerdefinierte Funktionen fÃ¼r die ErhÃ¶hung des Automatisierungsgrades schreiben.
- Kennt die Struktur von Optimierungsaufgaben und die notwendigen Mittel.
- Kann eine Zielfunktion definieren und eine Zielfunktion verwenden.
- Kennt die verschiedenen Arten von Nebenbedingungen fÃ¼r die Optimierungsprobleme.
- Kann die Optimierung untersuchen und die Ergebnisse interpretieren.
- Kann die Toolbox anwenden 15.Kann den App Designer anwenden.
- Kann die Callback-Funktionen fÃ¼r mehrere Komponenten anwenden.
- Kann robuste und flexible Apps erstellen und anpassen.
- Kann lokale Anwendungsdaten hinzufÃ¼gen.
- Kann Apps mit mehreren Fenstern fÃ¼r Dialoge und Hilfsanwendungen erstellen.
-->
<!--
- Knows the important functionalities and the associated user interfaces.
- Can enter commands and create numeric and text variables.
- Can label graphics.
- Can create and execute scripts.
- Can calculate with vectors.
- Can access and change values in variables.
- Can create, calculate and manipulate matrices.
- Can import and process tabular data.
- Can extract and analyse partial data sets.
- Can perform a complete data analysis.
- Can program branches and loops.
- Can write user-defined functions to increase the level of automation.
- Knows the structure of optimisation tasks and the necessary means.
- Can define an objective function and use an objective function.
- Knows the different types of constraints for the optimisation problems.
- Can investigate optimisation and interpret the results.
- Can use the toolbox 15.Can use the app designer.
- Can apply the callback functions for multiple components.
- Can create and customise robust and flexible apps.
- Can add local application data.
- Can create apps with multiple windows for dialogues and helper apps.
-->
----

Last Edited on: 09/03/2021
