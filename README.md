<h2>Hi, I'm Ioannis Christodoulakis!</h2>
<img align='right' src="https://media1.giphy.com/media/Wn74RUT0vjnoU98Hnt/200.gif" width="230">
<p><em>Hardware Engineer at <a href="https://new.siemens.com/ch/de.html?gclid=EAIaIQobChMI7KaQhNag7wIVTdnVCh2OvQo5EAAYASAAEgIZDvD_BwE">Siemens AG</a> and Application Developer at <a href="https://www.zg.ch/behoerden/volkswirtschaftsdirektion/hfie">HFIE</a>
</em></p>

### A little more about me...

I'm a passionate self-taught software engineer from Greece. My passion for software lies with dreaming up ideas and making them come true with elegant interfaces. I take great care in the experience, architecture, and code quality of the things I build.

I am also an open-source enthusiast and maintainer. I learned a lot from the open-source community and I love how collaboration and knowledge sharing happened through open-source. I like to explore new technologies and develop software solutions. I am always on the lookout for new projects to work on and new people to collaborate with.

<img src="https://media.giphy.com/media/LnQjpWaON8nhr21vNW/giphy.gif" width="60"> <em><b>I love connecting with different people</b> so if you want to say <b>hi, I'll be happy to meet you more!</b> üòä</em>

### Projects

- [Sudoku (Python)](https://github.com/YodaCh96/sudoku)
- [NIM (C)](https://github.com/YodaCh96/nim-game) [Completed ‚úîÔ∏è]
- [Dice rolling simulator (Python)](https://github.com/YodaCh96/dice-rolling-simulator) [Completed ‚úîÔ∏è]
- [Mathgraphs (Matlab)](https://github.com/YodaCh96/mathgraphs) [Completed ‚úîÔ∏è]
- [Reaktionsspiel (Arduino)](https://github.com/YodaCh96/reaktionsspiel) [Completed ‚úîÔ∏è]
- [Snake (Arduino)](https://github.com/YodaCh96/snake-game) [Completed ‚úîÔ∏è]

### Courses üìö

- [Python tutorial w3schools](https://www.w3schools.com/python/default.asp) [Completed ‚úîÔ∏è]
- [Python Crash Course](https://www.amazon.de/Python-Crash-Course-Hands-Project-Based/dp/1593276036) [Completed ‚úîÔ∏è]
- [HTML tutorial w3schools](https://www.w3schools.com/html/default.asp) [Completed ‚úîÔ∏è]
- [CSS tutorial w3schools](https://www.w3schools.com/css/default.asp) [Completed ‚úîÔ∏è]

### üõ† &nbsp;Tech Stack

![Python](https://img.shields.io/badge/-Python-05122A?style=flat&logo=python)&nbsp;
![Java](https://img.shields.io/badge/-Java-05122A?style=flat&logo=Java&logoColor=FFA518)&nbsp;
![C](https://img.shields.io/badge/-C-05122A?style=flat&logo=C&logoColor=A8B9CC)&nbsp;
![C++](https://img.shields.io/badge/-C++-05122A?style=flat&logo=C%2B%2B&logoColor=00599C)&nbsp;
![R (Statistics)](https://img.shields.io/badge/-R-05122A?style=flat&logo=R&logoColor=276DC3)
![HTML](https://img.shields.io/badge/-HTML-05122A?style=flat&logo=HTML5)&nbsp;
![CSS](https://img.shields.io/badge/-CSS-05122A?style=flat&logo=CSS3&logoColor=1572B6)&nbsp;
![Git](https://img.shields.io/badge/-Git-05122A?style=flat&logo=git)&nbsp;
![GitHub](https://img.shields.io/badge/-GitHub-05122A?style=flat&logo=github)&nbsp;
![Markdown](https://img.shields.io/badge/-Markdown-05122A?style=flat&logo=markdown)
![Visual Studio Code](https://img.shields.io/badge/-Visual%20Studio%20Code-05122A?style=flat&logo=visual-studio-code&logoColor=007ACC)&nbsp;
![Eclipse](https://img.shields.io/badge/-Eclipse-05122A?style=flat&logo=eclipse-ide&logoColor=2C2255)

---

[![](https://raw.githubusercontent.com/YodaCh96/YodaCh96/master/profile-summary-card-output/nord_dark/0-profile-details.svg)](https://github.com/vn7n24fzkq/github-profile-summary-cards)
[![](https://raw.githubusercontent.com/YodaCh96/YodaCh96/master/profile-summary-card-output/nord_dark/1-repos-per-language.svg)](https://github.com/vn7n24fzkq/github-profile-summary-cards) [![](https://raw.githubusercontent.com/YodaCh96/YodaCh96/master/profile-summary-card-output/nord_dark/2-most-commit-language.svg)](https://github.com/vn7n24fzkq/github-profile-summary-cards)
[![](https://raw.githubusercontent.com/YodaCh96/YodaCh96/master/profile-summary-card-output/nord_dark/3-stats.svg)](https://github.com/vn7n24fzkq/github-profile-summary-cards) [![](https://raw.githubusercontent.com/YodaCh96/YodaCh96/master/profile-summary-card-output/nord_dark/4-productive-time.svg)](https://github.com/vn7n24fzkq/github-profile-summary-cards)

----

<!-- ### Hardware Engineer at GIBZ -->

<!-- #### Hardware and software engineering -->

<!-- ### Application Development at HFIE -->

<!-- ### Strukturierte Programmierung -->
<!-- #### Structured programming -->

<!-- #### Kompetenzen -->
<!-- ##### Skills -->

<!--
- Ein Problem analysieren und einen geeigneten Algorithmus zur L√∂sung mit den Grundelementen Zuweisung, Verzweigung und Schleife entwerfen und in Form einer Ablaufstruktur abbilden.
- Schnittstellen zwischen Modulen bestimmen und mit einer strukturierten Methode (Structured Charts, Data Dictionary, Modulspezifikation) dokumentieren.
- Die erforderlichen Datenstrukturen f√ºr Eingabe, Verarbeitung und Ausgabe bestimmen und ihre Datentypen festlegen.
- Datentypen und Datenstrukturen wie Structs und Arrays hinsichtlich Speichergr√∂sse analysieren.
- Benutzerschnittstelle auf Konsolenbasis f√ºr die Eingabe und Ausgabe der Daten erstellen.
- Ein komplexeres Problem auf kleinere Teilprobleme aufteilen und in Unterprogrammen (Funktionen) umsetzen.
- Den Quellcode verst√§ndlich darstellen (Variablennamen, Struktur, Einr√ºckungen, Kommentare), um die Nachvollziehbarkeit des Programms sicher zu stellen.
- Einen Debugger einsetzen um die Programmausf√ºhrung zu √ºberwachen und Fehler zu erkennen.
- Programmcode auf funktionale Korrektheit testen.
- Abnahmetests (Black-Box-Test) definieren, um die fehlerfreie Verarbeitung des Programms sicher zu stellen.
-->
<!--
- Analyse a problem and design a suitable algorithm to solve it using the basic elements of assignment, branching and looping and map it in the form of a flow structure.
- Determine interfaces between modules and document them with a structured method (structured charts, data dictionary, module specification).
- Determine the required data structures for input, processing and output and define their data types.
- Analyse data types and data structures such as structs and arrays with regard to memory size.
- Create a console-based user interface for data input and output.
- Divide a more complex problem into smaller subproblems and implement them in subroutines (functions).
- Present the source code in a comprehensible way (variable names, structure, indentations, comments) to ensure the comprehensibility of the programme.
- Use a debugger to monitor programme execution and detect errors.
- Test programme code for functional correctness.
- Define acceptance tests (black box test) to ensure error-free processing of the programme.
-->
<!-- #### Kenntnisse -->
<!-- ##### Knowledge -->

<!--
- Kennt die wichtigsten Kontrollstrukturen der strukturierten Programmierung (Sequenz, Selektion, Iteration) und kann an Beispielen erl√§utern, welche Sachverhalte im Ablauf eines Algorithmus diesen Kontrollstrukturen entsprechen.
- Kennt eine Notation f√ºr die Abbildung einer Programmlogik (z.B. Nassi Shneidermann) und kann aufzeigen, wie darin die wichtigsten Kontrollstrukturen und der Ablauf eines Programms abgebildet werden.
- Kennt dargestellte Sachverhalte in einem Struktogramm und weitere Vorgaben, die bei der Bildung von Modulen zu ber√ºcksichtigen sind und kann aufzeigen, wie damit die √úbersichtlichkeit eines Programms verbessert und die Effizienz der Programmierung gesteigert werden kann.
- Kennt Techniken zur Darstellung von Beziehungen zwischen Modulen und kann erl√§utern, wie damit die Reihenfolge der Aufrufe und die √úbergabeparameter dargestellt werden k√∂nnen.
- Kennt die Informationen, welche ein Data Dictionary enth√§lt und kann erl√§utern, zu welchem Zweck diese Informationen bei der Erstellung eines Programms genutzt werden k√∂nnen.
- Kennt den Unterschied zwischen Wertevariablen und Referenzvariablen / Zeigervariablen.
- Kennt die wichtigsten Datentypen (char, int, float, double, string), ihren Speicherbedarf und Wertebereich.
- Kennt die Regeln der impliziten und expliziten Datentypenkonvertierung und kann aufzeigen, welche Auswirkungen diese hinsichtlich Genauigkeit und Aussage haben.
- Kennt Eigenschaften von einzelnen abstrakten Datentypen.
- Kennt die Eigenschaften und Vorteile der Verwendung von Arrays.
- Kennt den grundlegenden Aufbau eines Programms (Positionierung von Deklaration, Definition und Verarbeitung usw.) und kann diesen Aufbau an einem Programm beispielhaft erl√§utern.
- Kennt den Sinn und Zweck von Variablen und Konstanten, sowie deren Unterschied und G√ºltigkeitsbereich.
- Kennt  die  grundlegenden  Befehle  einer  Programmiersprache  zur  Umsetzung  von  Anweisungen, Kontrollstrukturen, Bedingungen und Operatoren.
- Kennt  die  grundlegenden  Befehle  einer  Programmiersprache  zur  Umsetzung  von  Anweisungen, Kontrollstrukturen, Bedingungen und Operatoren.
- Kennt die wichtigsten Regeln, die bei der Dateneingabe und Datenausgabe auf dem Bildschirm einzuhalten sind (Bezeichnung der Informationen, Format f√ºr Dateneingabe usw.) und kann erl√§utern, welche Probleme sich ergeben, wenn diese Regeln nicht eingehalten werden.
- Kennt eine Methode zur Abgrenzung und Zerlegung einer Aufgabenstellung in Funktionen (Top Down) und kann dies auch im Programmcode implementieren.
- Kennt den Aufbau von iterativen und rekursiven Algorithmen.
- Kennt Vor- und Nachteile sowie geeignete Einsatzgebiete des iterativen und des rekursiven Ansatzes.
- Kennt Codekonventionen (Programmstandards) und kann an Beispielen aufzeigen. Welchen Beitrag die Einhaltung solcher Konventionen f√ºr die Lesbarkeit und Wartbarkeit der Programme leisten.
- Kennt die wichtigsten Regeln f√ºr einen verst√§ndlichen Quellcode (sprechende Variablenbezeichnungen, geeignete Kommentare) und kann erl√§utern, welchen Beitrag diese Angaben zur Lesbarkeit von Programmen leisten.
- Kennt den Zweck, die Funktionen und die Bedienung eines Debugger.
- Kennt die M√∂glichkeiten einer Entwicklungsumgebung, sowie den Umgang mit Fehler und Warnmeldungen.
- Kennt den Nutzen von Breakpoints und der √úberwachung von Variablen zur Kontrolle von Programmabl√§ufen und Bedingungen.
- Kennt die grundlegenden Schritte, die bei einem Test durchlaufen werden m√ºssen und kann aufzeigen, welchen Beitrag diese zu einem qualitativ guten Ergebnis leisten.
- Kennt Kriterien f√ºr die Definition eines Testfalls und die gezielte Auswahl der Testdaten.
- Kennt Prinzipien, die bei der Definition von Testdaten und Testf√§llen ber√ºcksichtigt werden m√ºssen und kann aufzeigen, wie damit eine vollst√§ndige und korrekte Verarbeitung der Informationen in einem Programm (White Box Test, Black Box Test) √ºberpr√ºft werden kann.
- Kennt die Bedeutung von Grenzwerten beim Testen und kann an Beispielen aufzeigen, wie damit die Korrektheit von Bedingungen in Programmen nachgewiesen werden kann.
- Kennt den Aufbau eines Testprotokolls und kann an Beispielen aufzeigen, welche Ziele mit dem Testprotokoll verfolgt werden (Was, wann, von wem, wie intensiv und mit welchem Ergebnis getestet).
-->
<!--
- Knows the most important control structures of structured programming (sequence, selection, iteration) and can use examples to explain which facts in the flow of an algorithm correspond to these control structures.
- Knows a notation for the representation of a programme logic (e.g. Nassi Shneidermann) and can show how the most important control structures and the sequence of a programme are represented in it.
- Knows represented facts in a structure diagram and other specifications to be taken into account when forming modules and can show how this can improve the clarity of a programme and increase the efficiency of programming.
- Knows techniques for representing relationships between modules and can explain how this can be used to represent the order of calls and the passing parameters.
- Knows the information contained in a data dictionary and can explain the purpose for which this information can be used when creating a programme.
- Knows the difference between value variables and reference variables / pointer variables.
- Knows the most important data types (char, int, float, double, string), their memory requirements and value range.
- Knows the rules of implicit and explicit data type conversion and can show what effects these have in terms of accuracy and statement.
- Knows properties of individual abstract data types.
- Knows the properties and advantages of using arrays.
- Knows the basic structure of a programme (positioning of declaration, definition and processing, etc.) and can explain this structure using a programme as an example.
- Knows the meaning and purpose of variables and constants, as well as their difference and range of validity.
- Knows the basic commands of a programming language for implementing instructions, control structures, conditions and operators.
- Knows the basic commands of a programming language for implementing instructions, control structures, conditions and operators.
- Knows the main rules to be followed for data input and data output on the screen (designation of information, format for data input, etc.) and can explain what problems arise if these rules are not followed.
- Knows a method for delimiting and breaking down a task into functions (top down) and can also implement this in the programme code.
- Knows the structure of iterative and recursive algorithms.
- Knows the advantages and disadvantages as well as suitable areas of application of the iterative and recursive approach.
- Knows code conventions (programme standards) and can demonstrate them with examples. What contribution adherence to such conventions makes to the readability and maintainability of programmes.
- Knows the most important rules for comprehensible source code (speaking variable names, suitable comments) and can explain what contribution these details make to the readability of programmes.
- Knows the purpose, functions and operation of a debugger.
- Knows the possibilities of a development environment, as well as how to deal with errors and warning messages.
- Knows the usefulness of breakpoints and monitoring variables to control programme sequences and conditions.
- Knows the basic steps to go through in a test and can demonstrate how these contribute to a good quality result.
- Knows criteria for the definition of a test case and the specific selection of test data.
- Knows principles that must be taken into account when defining test data and test cases and can show how this can be used to check complete and correct processing of the information in a programme (white box test, black box test).
- Knows the importance of limit values in testing and can show by means of examples how the correctness of conditions in programmes can be verified.
- Knows the structure of a test protocol and can use examples to show which goals are pursued with the test protocol (what is tested, when, by whom, how intensively and with what result).
-->

<!-- ### Algorithmen & Datenstrukturen -->
<!-- #### Algorithms & Data Structures -->

<!-- #### Kompetenzen -->
<!-- ##### Skills -->

<!--
- Verschiedene Datenstrukturen kennen und anwenden.
- Evaluation geeigneter Datenstrukturen.
- Verschiedene Such- und Sortieralgorithmen anwenden.
- Zeit- und Speicherkomplexit√§t hinsichtlich bekannter Algorithmen verstehen.
- Endliche Automaten verstehen und anwenden.
-->
<!--
- Know and apply different data structures.
- Evaluate suitable data structures.
- Apply different search and sorting algorithms.
- Understand time and memory complexity with respect to known algorithms.
- Understand and apply finite automata.
-->
<!-- #### Kenntnisse -->
<!-- ##### Knowledge -->

<!--
- Funktionsweise relevanter Datenstrukturen (z.B. Array, Liste, Stack, Queue, Baum, Tabellen) erkl√§ren.
- G√§ngige Datenstrukturen selbst√§ndig implementieren.
- Datenstrukturen hinsichtlich Funktionalit√§t, Effizienz und Leistungsf√§higkeit beurteilen.
- Geeignete Datenstrukturen zur L√∂sung eines gegebenen Problems ausw√§hlen.
- Konzepte zum Suchen nach Buchstabenfolgen kennen und implementieren (z.B. Regul√§re Ausdr√ºcke, unscharfe Suche, String-Matching Algorithmen).
- Klassische Algorithmen zur Suche in Listen, B√§umen und Graphen verstehen und selbst√§ndig implementieren.
- Klassische Sortieralgorithmen (z.B. Quicksort, Bubblesort, Mergesort, ...) verstehen und selbst√§ndig implementieren.
- Konzepte der Zeit- und Speicherkomplexit√§t verstehen.
- Bekannte Such- und Sortieralgorithmen hinsichtlich ihrer Zeit- und Speicherkomplexit√§t beurteilen.
- Geeignete Such- und Sortieralgorithmen f√ºr eine gegebene Problemstellung ausw√§hlen und implementieren.
- Verschiedene Klassen endlicher Automaten kennen (z.B. Akzeptoren, Transduktoren).
- Anwendungsgebiete endlicher Automaten in der Softwareentwicklung kennen.
- Einfache endliche Automaten implementieren.
-->
<!--
- Explain how relevant data structures (e.g. array, list, stack, queue, tree, tables) work.
- Implement common data structures independently.
- Evaluate data structures in terms of functionality, efficiency and performance.
- Select suitable data structures to solve a given problem.
- Know and implement concepts for searching for letter sequences (e.g. regular expressions, fuzzy search, string matching algorithms).
- Understand and independently implement classical algorithms for searching lists, trees and graphs.
- Understand classical sorting algorithms (e.g. quicksort, bubblesort, mergesort, ...) and implement them independently.
- Understand concepts of time and memory complexity.
- Evaluate known search and sorting algorithms with regard to their time and memory complexity.
- Select and implement suitable search and sorting algorithms for a given problem.
- Know different classes of finite automata (e.g. acceptors, transductors).
- Know areas of application of finite automata in software development.
- Implement simple finite automata.
-->

<!-- ### Datenbanktechnik -->
<!-- #### Database technology -->

<!-- #### Kompetenzen -->
<!-- ##### Skills -->

<!--
- Daten bzw. Datenbestand nach den f√ºr die Verarbeitung resp. Auswertung wichtigen Merkmalen hinsichtlich Struktur (Text, Datenbl√§tter, Datenbank usw.) charakterisieren.
- Unstrukturierte Daten in eine strukturierte, bearbeitbare Form bringen, um Auswertungen zu erm√∂glichen.
- F√ºr Daten und Zusammenh√§nge eine geeignete visuell erfassbare Form w√§hlen und diese in der gew√§hlten Form darstellen.
- Konzeptionelles Datenbankschema interpretieren anhand von Entit√§ten, Attributen und Beziehungen.
- Konzeptionelles Datenmodell erstellen und fehlende Informationen ermitteln bzw. Redundanzen kl√§ren.
- Ein gegebenes ERM in ein internes Datenbankschema √ºberf√ºhren (Definieren von Tabellen/Relationen, Schl√ºsseln, Indizes, Konsistenzbedingungen).
- Logisches Datenbankschema ermitteln, normalisieren und als Diagramm darstellen.
- Logisches Datenbankschema mit einer Datenbanksoftware implementieren.
- Mit einer Datenbanksoftware Benutzerschnittstellen zur Erfassung, Ver√§nderung und Auswertung von Daten unter Ber√ºcksichtigung von Datenschutz und Datensicherheit in einer Datenbank erstellen.
- Implementiert ein vorgegebenes, logisches Datenbankschema in ein relationales Datenbank Management System (RDBMS) mit einer Datenbanksoftware oder mit Structured Query Language-Befehlen (SQL).
- Mit SQL-Befehlen Transaktionen zur Bearbeitung und Auswertung der Datenbank ausf√ºhren.
- Selektiert und manipuliert die Datenbest√§nde eines RDBMS mit SQL-Befehlen.
-->
<!--
- Characterise data or data stock according to the features important for processing or evaluation with regard to structure (text, data sheets, database, etc.).
- Put unstructured data into a structured, processable form to enable evaluations.
- Select a suitable visually recordable form for data and correlations and present them in the chosen form.
- Interpret conceptual database schema using entities, attributes and relationships.
- Create conceptual data model and identify missing information or clarify redundancies.
- Convert a given ERM into an internal database schema (define tables/relations, keys, indices, consistency conditions).
- Determine logical database schema, normalise it and represent it as a diagram.
- Implement logical database schema with database software.
- Using database software, create user interfaces for entering, changing and evaluating data, taking into account data protection and data security in a database.
- Implement a given logical database schema in a relational database management system (RDBMS) using database software or Structured Query Language (SQL) commands.
- Use SQL commands to execute transactions to manipulate and evaluate the database.
- Selects and manipulates the datasets of an RDBMS with SQL commands.
-->
<!-- #### Kenntnisse -->
<!-- ##### Knowledge -->

<!--
- Kennt die verschiedenen Formen von Daten (numerische - Messdaten/ Klassifikationen; verbale - Texte in schriftlicher oder gesprochener Form; nonverbale - Musik, Filme, Videos) die auf einem Datentr√§ger gespeichert werden k√∂nnen und kann aufzeigen, wie sich diese Daten hinsichtlich der Auswertbarkeit mit einem Computersystem verhalten.
- Kennt die Strukturmerkmale verschiedener Informationsquellen (Textdokument, Datenbl√§tter, Datenbanken) und kann erl√§utern, welche Konsequenzen sich daraus f√ºr die elektronische Auswertung dieser Datenquellen ergeben.
- Kennt die Beziehungen zwischen Datenstrukturen (Assoziationen, Kardinalit√§ten) und kann an Beispielen aus dem Alltag aufzeigen, welche Sachverhalte sich damit in einem Datenbestand abbilden lassen.
- Kann die Skalentypen nominal ("alt" - "jung", "ungen√ºgend" - "gen√ºgend" - "gut"), ordinal (R√§nge, Noten etc.) und metrisch (Alter, Gr√∂sse etc.) unterscheiden und die Konsequenzen aufzeigen, die sich daraus f√ºr die Auswertungsm√∂glichkeiten ableiten lassen.
- Kennt die verbreiteten Datentypen (Zahl, Zeit, Datum, Text etc.) und kann deren Grenzen hinsichtlich der Auswertbarkeit von Daten aufzeigen.
- Kennt die einfachsten statistischen Kenngr√∂ssen (Mittelwert, Minimum, Maximum) und kann aufzeigen, welche Voraussetzungen (Skalentypen, Anzahl Beobachtungen, Qualit√§t der Daten etc.) erf√ºllt sein m√ºssen, damit diese eine zuverl√§ssige Aussage machen.
- Kennt die einfachsten Diagrammtypen f√ºr die Darstellung von Daten und kann erl√§utern, bei welchen Skalentypen der Daten (metrisch-, nominal-, ordinal-skalierte) sich diese eignen.
- Kennt die Begriffe Entit√§t, Attribut und Beziehung in einem konzeptionellen Datenbankschema und deren Darstellung.
- Kennt die unterschiedlichen Kardinalit√§ten und deren Aussage bez√ºglich der Beziehungen.
- Kennt die methodische Vorgehensweise bei der Entwicklung eines konzeptionellen Datenmodells und kann f√ºr die einzelnen Schritte erl√§utern, wie dabei vorgegangen wird.
- Kennt die Regeln, welche beim Spezialisieren bzw. Generalisieren von Objekten in Entit√§tsmengen und Beziehungen zu beachten sind.
- Kennt die Elemente der Notation eines ERM und kann anhand von Beispielen erl√§utern, welche Art von Datenelementen und -beziehungen damit abgebildet werden.
- Kennt Aufbau und Struktur eines Datenbankschemas und kann aufzeigen, welche Aussagen die Elemente hinsichtlich der physischen Implementierung der Datenbank machen.
- Kennt das Vorgehen eines Datenbankentwurfs (Tabellen identifizieren, Attribute definieren, Beziehungen kl√§ren) und kann diesen Entwurf als ER-Diagramm darstellen.
- Kennt die Elemente eines Datenbankprogramms zur Umsetzung eines Datenmodells in ein physisches Datenbankschema.
- Kennt GUI-Komponenten und Formularfelder f√ºr die Definition von Benutzerschnittstellen zur Erfassung, Ver√§nderung sowie Auswertung von Daten.
- Kennt die wichtigsten Regeln, die bei der ergonomischen Gestaltung einer Benutzeroberfl√§che f√ºr eine Datenbank hinsichtlich Abfolge und Bezeichnung der Informationen einzuhalten sind.
- Kennt die wichtigsten Abfragen zur Manipulation, Selektion und Auswertung von Datenbest√§nden.
-  Kennt die eigene Entwicklungsumgebung und Werkzeuge (Tools), um SQL-Skripte zu erstellen und m√∂gliche Codierungsfehler zu beheben.
-  Kennt den wesentlichen Aufbau (Syntax) und die Bedeutung (Semantik) von SQL-Befehlen.
-  Kennt die wesentlichen Bestandteile eines relationalen Datenbank Management Systems (RDBMS).
-  Kennt die wichtigsten SQL-Befehle oder eine Datenbanksoftware, um eine Datenbank in einem RDBMS gem√§ss Vorgaben einzurichten.
-  Kennt die Befehle einer Datenmanipulations- und Abfragesprache (DML, SQL) zur Manipulation, Selektion und Auswertung von Datenbest√§nden.
-  Kennt die wichtigsten SQL-Befehle und deren Aufbau zur Selektion und Auswertung von Datenbest√§nden (√ºber eine oder mehrere Tabellen).
-  Kennt die wichtigsten SQL-Befehle und deren Aufbau zur Manipulation von Datenbest√§nden.
-  Kennt h√§ufige Fehlerquellen bei der Programmierung mit SQL und Vorgehensweisen zur selbst√§ndigen Fehlerbehebung.
-->
<!--
- Knows the different forms of data (numerical - measurement data/ classifications; verbal - texts in written or spoken form; non-verbal - music, films, videos) that can be stored on a data carrier and can show how these data behave in terms of evaluability with a computer system.
- Knows the structural features of different information sources (text document, data sheets, databases) and can explain which consequences result from this for the electronic evaluation of these data sources.
- Knows the relationships between data structures (associations, cardinalities) and can use examples from everyday life to show which facts can thus be represented in a data set.
- Can distinguish between nominal ("old" - "young", "insufficient" - "sufficient" - "good"), ordinal (ranks, grades, etc.) and metric (age, height, etc.) scale types and show the consequences that can be derived from this for the evaluation possibilities.
- Knows the common types of data (number, time, date, text, etc.) and can point out their limits with regard to the evaluability of data.
- Knows the simplest statistical parameters (mean, minimum, maximum) and can show which conditions (scale types, number of observations, quality of the data, etc.) must be fulfilled in order to make a reliable statement.
- Knows the simplest chart types for the representation of data and can explain for which scale types of data (metric-, nominal-, ordinal-scaled) they are suitable.
- Knows the concepts of entity, attribute and relationship in a conceptual database schema and how they are represented.
- Knows the different cardinalities and what they mean in terms of relationships.
- Knows the methodological procedure for developing a conceptual data model and can explain how to proceed for the individual steps.
- Knows the rules to be observed when specialising or generalising objects in entity sets and relationships.
- Knows the elements of the notation of an ERM and can explain by means of examples what kind of data elements and relationships are represented with it.
- Knows the structure of a database schema and can show what statements the elements make with regard to the physical implementation of the database.
- Knows the procedure of a database design (identify tables, define attributes, clarify relationships) and can present this design as an ER diagram.
- Knows the elements of a database programme to convert a data model into a physical database schema.
- Knows GUI components and form fields for defining user interfaces for entering, changing as well as evaluating data.
- Knows the most important rules to be observed in the ergonomic design of a user interface for a database with regard to the sequence and designation of information.
- Knows the most important queries for manipulating, selecting and evaluating databases.
- Knows the own development environment and tools (tools) to create SQL scripts and to correct possible coding errors.
- Knows the essential structure (syntax) and the meaning (semantics) of SQL commands.
- Knows the essential components of a relational database management system (RDBMS).
- Knows the most important SQL commands or database software to set up a database in an RDBMS according to specifications.
- Knows the commands of a data manipulation and query language (DML, SQL) for manipulating, selecting and evaluating data sets.
- Knows the most important SQL commands and their structure for selecting and evaluating datasets (via one or more tables).
- Knows the most important SQL commands and their structure for manipulating data sets.
- Knows common sources of errors when programming with SQL and procedures for independent error correction.
-->

<!-- ### Objektorientiert implementieren -->
<!-- #### Implement object-oriented -->

<!-- #### Kompetenzen -->
<!-- ##### Skills -->

<!--
- Die Notation dynamischer und statischer Strukturen einer Anwendung mittels Unified Modeling Language (UML) nachvollziehen.
- Klassenbasiertes Design implementieren.
- Eine Benutzerschnittstelle entwerfen und implementieren.
- Klassen der Anwendung systematisch, unter Verwendung der hierf√ºr vorgesehenen Infrastruktur, dokumentieren.
- Beim Programmieren vorgegebene Standards und Richtlinien einhalten, das Programm inline dokumentieren und dabei auf Wartbarkeit und Nachvollziehbarkeit achten.
- Programm auf Einhaltung der Funktionalit√§t testen, Fehler erkennen und beheben.
- F√ºr funktionale Einheiten einer Anwendung Testf√§lle implementieren, um die Anwendung automatisch zu pr√ºfen (Unit Test).
-->
<!--
- Understand the notation of dynamic and static structures of an application using Unified Modelling Language (UML).
- Implement class-based design.
- Design and implement a user interface.
- Document classes of the application systematically, using the infrastructure provided for this purpose.
- Comply with standards and guidelines when programming, documenting the programme inline, taking care to ensure maintainability and traceability.
- Test the programme for compliance with functionality, detect and correct errors.
- Implement test cases for functional units of an application in order to automatically test the application (unit test).
-->
<!-- #### Kenntnisse -->
<!-- ##### Knowledge -->

<!--
- Kennt Abstraktionsmittel wie Beziehungen, Klassen, Objekte, Attribute und Methoden, mit denen die reale Welt im Design abgebildet wird.
- Versteht die Klasse als abstrakten Datentyp (ADT).
- Versteht das Zusammenspiel mehrerer Klassen in einer Anwendung.
- Kennt die Beziehungstypen wie Assoziation, Aggregation, Komposition zwischen Klassen.
- Kennt die Bedeutung von Super- und Sub-Klassen, die f√ºr die Implementation der Anwendung n√∂tig sind und das klassenbasierte Design vervollst√§ndigen.
- Kann durch die Anwendung von Vererbung Redundanzen im Klassendesign eliminieren.
- Ber√ºcksichtigt beim Erstellen von Vererbungshierarchien das Prinzip von Spezialisierung / Generalisierung inklusive abstrakter Klassen.
- Kennt Diagrammnotationen zur Darstellung von Schnittstellen.
- Kennt Diagrammnotationen zur Darstellung des Meldungsaustausches zwischen Objekten.
- Kann f√ºr ein Fallbeispiel die objektorientierte Analyse durchf√ºhren und die Ergebnisse unter Zuhilfenahme der Diagramme: Kontextdiagramm, Use Case Diagramm, Objektdiagramm, Klassendiagramm und  Sequenzdiagramm darstellen.
- Kennt eine objektorientierte Sprache, welche f√ºr die Umsetzung des klassenbasierten Designs geeignet ist.
- Kann das Prinzip des Information Hiding und der Kapselung beim Entwurf von Klassen anwenden.
- Versteht den Unterschied zwischen dem Programm zur Kompilationszeit (Klassen) und zur Laufzeit (sich referenzierende Objekte).
- Kennt Elemente einer objektorientierten Sprache f√ºr die Umsetzung der Vererbung im objektorientierten Design.
- Kennt Elemente einer objektorientierten Sprache f√ºr das √úberschreiben von Methoden im objektorientierten Design.
- Kann an einem Codebeispiel den Effekt von Polymorphie aufzeigen.
- Kennt Elemente einer objektorientierten Sprache f√ºr die Realisierung von Schnittstellen und abstrakten Klassen.
- Kann aufzeigen, wie durch die Nutzung von Schnittstellen der Code unabh√§ngig erstellt und getestet werden kann.
- Kennt die wichtigsten Regeln f√ºr den Aufbau einer Benutzerschnittstelle.
- Kennt L√∂sungsans√§tze f√ºr die Verarbeitung und Validierung von Benutzerinteraktionen.
- Kennt die M√∂glichkeiten der Dokumentationsinfrastruktur und weiss wie die Programmeinheiten gem√§ss Vorgaben zu dokumentieren sind.
- Kennt die wichtigsten Regeln f√ºr einen verst√§ndlichen Quellcode (sprechende Komponenten- und Variablenbezeichnungen, optische Strukturierung, sinnvolle Kommentare).
- Kennt die Elemente eines Testfalls (zu testende Funktion oder Verarbeitung, Eingabedaten, erwartete Ergebnisse).
- Kennt die Bedeutung des Testens f√ºr die Sicherung der Programmqualit√§t.
- Kennt das Hilfsmittel des Mockings um Abh√§ngigkeiten aus den Testf√§llen zu eliminieren.
- Kennt Mittel zur Isolierung der Testdaten und Testf√§lle, um die gegenseitige Unabh√§ngigkeit der Testf√§lle zu garantieren.
- Kennt Werkzeuge zur Implementation von isolierten Testf√§llen.
- Kennt Vorgehen um f√ºr Programmteile Testf√§lle mittels geeigneter Grenzwerte oder Pfadpr√ºfungen zu finden und festzulegen.
- Kennt die zur Verf√ºgung gestellten Mittel einer Testinfrastruktur um die Testf√§lle zu implementieren.
- Kennt Mittel, die Abdeckung der Tests zu messen.
-->
<!--
- Knows abstraction tools such as relationships, classes, objects, attributes and methods used to represent the real world in design.
- Understands class as an abstract data type (ADT).
- Understands the interaction of multiple classes in an application.
- Knows the relationship types such as association, aggregation, composition between classes.
- Knows the importance of super and sub classes which are necessary for the implementation of the application and complete the class-based design.
- Can eliminate redundancy in class design through the use of inheritance.
- Considers the principle of specialisation / generalisation including abstract classes when creating inheritance hierarchies.
- Knows diagram notations to represent interfaces.
- Knows diagram notations to represent message exchanges between objects.
- Can carry out object-oriented analysis for a case study and present the results with the aid of diagrams: Context diagram, Use Case diagram, Object diagram, Class diagram and Sequence diagram.
- Knows an object-oriented language suitable for implementing class-based design.
- Can apply the principle of information hiding and encapsulation when designing classes.
- Understands the difference between the programme at compile time (classes) and at run time (referencing objects).
- Knows elements of an object-oriented language for implementing inheritance in object-oriented design.
- Knows elements of an object-oriented language for overriding methods in object-oriented design.
- Can demonstrate the effect of polymorphism in a code example.
- Knows elements of an object-oriented language for the realisation of interfaces and abstract classes.
- Can show how code can be created and tested independently through the use of interfaces.
- Knows the most important rules for building a user interface.
- Knows approaches for processing and validating user interactions.
- Knows the possibilities of the documentation infrastructure and how to document the programme units according to specifications.
- Knows the most important rules for an understandable source code (speaking component and variable names, visual structuring, meaningful comments).
- Knows the elements of a test case (function or processing to be tested, input data, expected results).
- Knows the importance of testing for ensuring programme quality.
- Knows the tool of mocking to eliminate dependencies from test cases.
- Knows means of isolating test data and test cases to guarantee mutual independence of test cases.
- Knows tools for implementing isolated test cases.
- Knows procedures to find and define test cases for programme parts by means of suitable limits or path checks.
- Knows the means provided by a test infrastructure to implement the test cases.
- Knows the means to measure the coverage of the tests.
-->

<!-- ### Prozesssimulation mit Matlab -->
<!-- #### Process simulation with Matlab -->

<!-- #### Kompetenzen -->
<!-- ##### Skills -->

<!--
- Arbeiten mit Matlab- Oberfl√§che.
- Eingeben von Befehlen und Erzeugen von Variablen.
- Analyse und Visualisierung von Vektor- und Matrixdaten.
- Umgang mit verschiedenen Datentypen.
- Tabellarische Daten.
- Bedingte Datenauswahl und Datenorganisation.
- Datenanalyse.
- Automatisieren von Abl√§ufen mit Skripten und Funktionen.
- Programmieren von bedingten Anweisungen und Schleifen.
- Optimierungsprobleme l√∂sen.
- Zielfunktionen definieren.
- Nebenbedingungen festlegen.
- Ergebnisse analysieren und Laufzeit verbessern.
- Globale Optimierungsmethoden verwenden.
- Gestalten des Layouts mit dem App Designer.
- Erstellen von Callback-Funktionen f√ºr interaktive Komponenten.
- Erzeugen und aktualisieren grafischer Objekte.
- Erstellen von Anwendungskomponenten, die auf Benutzerverhalten reagieren.
- Erstellen von Apps mit mehreren Fenstern.
-->
<!--
- Working with Matlab interface.
- Entering commands and creating variables.
- Analysing and visualising vector and matrix data.
- Working with different types of data.
- Tabular data.
- Conditional data selection and data organisation.
- Data analysis.
- Automating procedures with scripts and functions.
- Programming conditional statements and loops.
- Solving optimisation problems.
- Defining objective functions.
- Set constraints.
- Analyse results and improve runtime.
- Use global optimisation methods.
- Designing the layout with the App Designer.
- Create callback functions for interactive components.
- Create and update graphical objects.
- Create application components that respond to user behaviour.
- Create apps with multiple windows.
-->
<!-- #### Kenntnisse -->
<!-- ##### Knowledge -->

<!--
- Kennt die wichtigen Funktionalit√§ten und die zugeh√∂rigen Benutzeroberfl√§chen.
- Kann Befehle eingeben und numerische Variablen und Textvariablen erstellen.
- Kann Grafiken beschriften.
- Kann Skripten erzeugen und ausf√ºhren.
- Kann mit Vektoren rechnen.
- Kann auf Werte in Variablen zugreifen und diese √§ndern.
- Kann Matrizen erstellen, berechnen und manipulieren.
- Kann tabellarische Daten importieren und verarbeiten.
- Kann Teildatens√§tze extrahieren und analysieren.
- Kann eine komplette Datenanalyse durchf√ºhren.
- Kann Verzweigungen und Schlaufen programmieren.
- Kann benutzerdefinierte Funktionen f√ºr die Erh√∂hung des Automatisierungsgrades schreiben.
- Kennt die Struktur von Optimierungsaufgaben und die notwendigen Mittel.
- Kann eine Zielfunktion definieren und eine Zielfunktion verwenden.
- Kennt die verschiedenen Arten von Nebenbedingungen f√ºr die Optimierungsprobleme.
- Kann die Optimierung untersuchen und die Ergebnisse interpretieren.
- Kann die Toolbox anwenden 15.Kann den App Designer anwenden.
- Kann die Callback-Funktionen f√ºr mehrere Komponenten anwenden.
- Kann robuste und flexible Apps erstellen und anpassen.
- Kann lokale Anwendungsdaten hinzuf√ºgen.
- Kann Apps mit mehreren Fenstern f√ºr Dialoge und Hilfsanwendungen erstellen.
-->
<!--
- Knows the important functionalities and the associated user interfaces.
- Can enter commands and create numeric and text variables.
- Can label graphics.
- Can create and execute scripts.
- Can calculate with vectors.
- Can access and change values in variables.
- Can create, calculate and manipulate matrices.
- Can import and process tabular data.
- Can extract and analyse partial data sets.
- Can perform a complete data analysis.
- Can program branches and loops.
- Can write user-defined functions to increase the level of automation.
- Knows the structure of optimisation tasks and the necessary means.
- Can define an objective function and use an objective function.
- Knows the different types of constraints for the optimisation problems.
- Can investigate optimisation and interpret the results.
- Can use the toolbox 15.Can use the app designer.
- Can apply the callback functions for multiple components.
- Can create and customise robust and flexible apps.
- Can add local application data.
- Can create apps with multiple windows for dialogues and helper apps.
-->
----

Last Edited on: 09/03/2021
